#!/usr/bin/env python3
"""
Generate e-book from recipe.json + story.md structure using Jinja2 templates.
Reads folders with recipe*.json and story.md, generates combined markdown + HTML index.

Usage:
    python scripts/generate_from_json.py --input-dir recipes --output-dir dist
"""

import os
import json
import re
import argparse
from pathlib import Path
from typing import List, Dict, Any, Tuple
from jinja2 import Environment, FileSystemLoader, select_autoescape


def slugify(text: str) -> str:
    """Create a URL-friendly slug from a string."""
    slug = re.sub(r"[^a-z0-9]+", "-", text.lower()).strip("-")
    return slug


def discover_recipe_folders(directory: str) -> List[Path]:
    """Discover all folders containing recipe*.json files."""
    recipe_folders = set()
    for root, _dirs, files in os.walk(directory):
        for file in files:
            if file.startswith('recipe') and file.endswith('.json'):
                recipe_folders.add(Path(root))
    return sorted(recipe_folders)


def load_recipe(recipe_file: Path) -> Dict[str, Any]:
    """Load and parse a recipe JSON file."""
    with open(recipe_file, 'r', encoding='utf-8') as f:
        return json.load(f)


def load_story(story_file: Path) -> Dict[str, str]:
    """
    Load story.md content and parse into sections.
    Returns dict with section names as keys (e.g., 'Background', 'Kumpli Notes', 'Cooking Moments').
    """
    if not story_file.exists():
        return {}
    
    with open(story_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Split by H2 sections (## Header)
    sections = {}
    current_section = None
    current_content = []
    
    for line in content.split('\n'):
        if line.startswith('## '):
            # Save previous section
            if current_section:
                sections[current_section] = '\n'.join(current_content).strip()
            # Start new section
            current_section = line[3:].strip()
            current_content = []
        else:
            current_content.append(line)
    
    # Save last section
    if current_section:
        sections[current_section] = '\n'.join(current_content).strip()
    
    return sections


def process_story_section_images(section_content: str, recipe_folder: Path, optimized_images_path: str) -> str:
    """Process image paths in a story section."""
    return process_image_paths(section_content, recipe_folder, optimized_images_path)


def process_image_paths(content: str, recipe_folder: Path, optimized_images_path: str) -> str:
    """Process image paths in story.md to point to optimized images."""
    
    def replace_image(match: Any) -> str:
    """Setup Jinja2 environment with templates."""
    env = Environment(
        loader=FileSystemLoader(template_dir),
        autoescape=select_autoescape(),
        trim_blocks=True,
        lstrip_blocks=True
    )
    return env


def process_image_paths(content: str, recipe_folder: Path, optimized_images_path: str) -> str:
    """Process image paths in story.md to point to optimized images."""
    
    def replace_image(match: Any) -> str:
        alt_text = match.group(1)
        image_path = match.group(2).strip()
        
        # If already pointing to optimized-images, leave it
        if image_path.startswith("optimized-images/") or image_path.startswith("./optimized-images/"):
            return match.group(0)
        
        # If it's a relative path in the recipe folder (like illustration.png, photo-1.png)
        if not image_path.startswith('../'):
            # Convert to optimized path using recipe folder structure
            recipe_slug = recipe_folder.name
            without_ext, _ = os.path.splitext(image_path)
            optimized_path = f"{optimized_images_path}/{recipe_slug}/{without_ext}.jpg"
            return f"![{alt_text}]({optimized_path})"
        
        # Handle ../images/ paths
        abs_img = (recipe_folder / image_path).resolve()
        parts = abs_img.parts
        
        if "images" in parts:
            idx = parts.index("images")
            subparts = parts[idx + 1:]
            rel_under_images = "/".join(subparts)
        else:
            rel_under_images = image_path.lstrip('./')
        
        # Change extension to .jpg
        without_ext, _ = os.path.splitext(rel_under_images)
        optimized_path = f"{optimized_images_path}/{without_ext}.jpg"
        return f"![{alt_text}]({optimized_path})"
    
    # Pattern to match markdown images: ![alt](path.ext)
    content = re.sub(
        r"!\[([^\]]*)\]\(([^)]+\.(?:png|jpg|jpeg))\)",
        replace_image,
        content,
        flags=re.IGNORECASE,
def render_recipe_folder(
    recipe_folder: Path,
    optimized_images_path: str,
    jinja_env: Environment
) -> Tuple[str, str, str, Dict[str, Any]]:
    """
    Render a complete recipe folder (recipe*.json + story.md) using Jinja2.
    Returns (chapter_title, chapter_slug, markdown_content, recipe_data_for_html).
    """
    # Discover all recipe*.json files
    recipe_files = sorted(recipe_folder.glob('recipe*.json'))
    
    if not recipe_files:
        return None
    
    # Load story.md and parse sections
    story_file = recipe_folder / 'story.md'
    story_sections = load_story(story_file)
    
    # Process image paths in each story section
    for section_name, section_content in story_sections.items():
        story_sections[section_name] = process_story_section_images(
            section_content, recipe_folder, optimized_images_path
        )
    
    # Load all recipes
    recipes_data = []
    for recipe_file in recipe_files:
        recipe = load_recipe(recipe_file)
        recipes_data.append(recipe)
    
    # Render recipes for markdown
    recipe_template = jinja_env.get_template('recipe.md.j2')
    rendered_recipes = []
    for recipe in recipes_data:
        rendered = recipe_template.render(recipe=recipe)
        rendered_recipes.append(rendered)
    
    # Use the first recipe's title as the chapter title
    first_recipe = recipes_data[0]
    chapter_title = first_recipe['title']
    chapter_slug = first_recipe['slug']
    
    # Render chapter using template
    chapter_template = jinja_env.get_template('chapter.md.j2')
    chapter_content = chapter_template.render(
        chapter_title=chapter_title,
        chapter_slug=chapter_slug,
        story_sections=story_sections,
        recipes=rendered_recipes
    )
    
    # Package data for HTML generation
    html_data = {
        'chapter_title': chapter_title,
        'chapter_slug': chapter_slug,
def generate_combined_markdown(
    recipe_folders: List[Path],
    output_dir: str,
    optimized_images_path: str,
    jinja_env: Environment
) -> Tuple[str, List[Tuple[str, str]], List[Dict[str, Any]]]:
    """
    Generate combined markdown file and collect ToC items + recipe data using Jinja2.
    Returns (combined_markdown_path, toc_items, recipes_html_data).
    """
    os.makedirs(output_dir, exist_ok=True)
    
    chapters = []
    toc_items = []
    recipes_html_data = []
    
    for recipe_folder in recipe_folders:
        result = render_recipe_folder(recipe_folder, optimized_images_path, jinja_env)
        
        if result:
            chapter_title, chapter_slug, markdown_content, html_data = result
            toc_items.append((chapter_title, chapter_slug))
            chapters.append(markdown_content)
            recipes_html_data.append(html_data)
    
    # Render book using template
    book_template = jinja_env.get_template('book.md.j2')
    combined_content = book_template.render(chapters=chapters)
    
    # Write combined file
    output_file = os.path.join(output_dir, "kumpli-recipes.md")
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(combined_content)
    
    return output_file, toc_items, recipes_html_data


def write_recipe_html_pages(recipes_html_data: List[Dict[str, Any]], output_dir: str, jinja_env: Environment) -> List[str]:
    """Generate individual HTML pages for each recipe."""
    recipes_dir = os.path.join(output_dir, "recipes")
    os.makedirs(recipes_dir, exist_ok=True)
    
    recipe_template = jinja_env.get_template('recipe-page.html.j2')
    generated_files = []
    
    for recipe_data in recipes_html_data:
        # Convert markdown to HTML in story sections
        import markdown
        story_sections_html = {}
        for section_name, section_content in recipe_data['story_sections'].items():
            story_sections_html[section_name] = markdown.markdown(section_content)
        
        recipe_data['story_sections'] = story_sections_html
        
        # Generate HTML
        html_content = recipe_template.render(**recipe_data)
        
        # Write file
        output_file = os.path.join(recipes_dir, f"{recipe_data['chapter_slug']}.html")
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(html_content)
        
        generated_files.append(output_file)
    
    return generated_files


def write_toc_html(toc_items: List[Tuple[str, str]], output_dir: str, jinja_env: Environment) -> str:
    return output_file, toc_items
def write_toc_html(toc_items: List[Tuple[str, str]], output_dir: str, jinja_env: Environment) -> str:
    """Write a simple ToC HTML using Jinja2 template."""
    os.makedirs(output_dir, exist_ok=True)
    html_path = os.path.join(output_dir, "index.html")

    # Render using template
    index_template = jinja_env.get_template('index.html.j2')
    html_content = index_template.render(toc_items=toc_items)

    with open(html_path, "w", encoding="utf-8") as f:
        f.write(html_content)

    return html_path

    # Generate combined markdown and ToC items
    combined_md, toc_items, recipes_html_data = generate_combined_markdown(
        recipe_folders, args.output_dir, args.optimized_images, jinja_env
    )
    print(f"Generated combined markdown: {combined_md}")

    # Generate individual HTML pages
    html_pages = write_recipe_html_pages(recipes_html_data, args.output_dir, jinja_env)
    print(f"Generated {len(html_pages)} individual recipe HTML page(s)")

    # Write ToC HTML (index.html)
    toc_html = write_toc_html(toc_items, args.output_dir, jinja_env)
    print(f"Generated ToC HTML: {toc_html}")


if __name__ == "__main__":
    main()

